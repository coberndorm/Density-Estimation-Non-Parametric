function classifiers=ColoringBorder(in,alpha,show,outlier,outlier2)

% T = samplingVS(ReadInfo, InfoInitialPoint, MapInfo, samples, factor, show,...
%                spName, replacement, uniqueness)
% 
% DESCRIPTION 
%   'samplingVS' sample the species presence-data(observations) over 
%   the generated map niche 
%
% REQUIRED INPUTS
%   ReadInfo: an strcuture generated by 'ReadLayers' function
%   InfoInitialPoint: and structure generated by 'InitialPoint' function
%   MapInfo: a structure generated by 'NicheGeneration' function
%   samples: a integer with the number of required samples 
%   factor (alpha): real number that define the sampling method
%   show: boolean variable (true, false), show the resulting niche map  
%         and the sampled points
%   spName: a string with the species name
%   replacement: boolean variable (true, false), perform a replacemet in 
%                the sample if true, or not replacement if false
%   
% OPTIONAL INPUTS
%   uniqueness: (default: false)
% 
% OUTPUTS:
%   T: a table with the species name 'spName', the longitude and 
%   the latitude of the virtual species observations
%%  

if nargin <2
    alpha = 1;
end
if nargin <3
    show = false;    
end
if nargin <4
    outlier=false;
end
if nargin <5
    outlier2=false:
end
%out1 and out2 will be the samples taken out by the outlier detection
out1=[];
out2=[];

T2 = in{1}.T2;
Z = in{1}.Z;
R = in{1}.R;

reps = size(Z);
caps = reps(3);
template = Z(:, :, 1);
data = NaN(length(template(:)), caps);

for i = 1 : caps
    template = Z(:, :, i);
    data(:, i) = template(:);
end

nanDetector = sum(data, 2);
pointer = ~isnan(nanDetector);
idx = find(pointer==1);


points = T2{:,4:end};
normalizers=[max(points(:,:));min(points(:,:))];
points(:,:)=(points(:,:)-normalizers(2,:))./(normalizers(1,:)-normalizers(2,:));
data(idx,:) =  (data(idx,:)-normalizers(2,:))./(normalizers(1,:)-normalizers(2,:));

if outlier
    [~,~,RD,chi_crt]=DetectMultVarOutliers(points(:,:));
    id_out=RD>chi_crt(4);
    out1=points(id_out,:);
    points=points(~id_out,:);
end

[coeff,~,~,~,explained]=pca(points(:,:));
pin=points(:,:)*coeff(:,1:3);

if ~isempty(out1)
    out1=out1*coeff(:,1:3);
end


if outlier2
    %siz=round(size(pin,1)*0.3);
    [~,~,RD,chi_crt]=DetectMultVarOutliers(pin);
    id_out=RD>chi_crt(4);
    out2=pin(id_out,:);
    pin=pin(~id_out,:);
end

nodes = boundary(pin(:,1),pin(:,2),pin(:,3),alpha);

boundPointsIndex = unique(nodes)';
boundPoints = points(boundPointsIndex,:);
pointsSize = length(boundPointsIndex);
samples = length(points);
radius = zeros(pointsSize,samples);
map = ones(reps(1), reps(2));

for i=1:pointsSize
    for j=1:samples
        radius(i,j)=norm(points(boundPointsIndex(i),:)-points(j,:));
    end
end
radius = radius(:,setdiff(1:end,boundPointsIndex))
radiusClass = min(radius)

response = NaN(pointsSize,length(template(:)));

for i=1:length(idx)
    for j=1:pointsSize
        response(j,idx(i)) = norm(points(boundPointsIndex(j),:)-data(idx(i),:));
    end
end
intensity = min(response(:,idx));

final = NaN(length(template(:)),1);

for i=1:length(idx)
    final(idx(i)) = sum(intensity(i)<=radiusClass);
end


final(idx) = final(idx)./(length(radiusClass));
map(:) = final(:);

classifiers.nodes = boundPoints;
classifiers.index = boundPointsIndex;
classifiers.radius = radiusClass;
classifiers.normalizers = normalizers;
classifiers.T2 = T2;
classifiers.map = map;

outT=[out1;out2];

if show
    trisurf(nodes,pin(:,1),pin(:,2),pin(:,3), 'Facecolor','cyan','FaceAlpha',0.8); axis equal;
    hold on
    plot3(pin(:,1),pin(:,2),pin(:,3),'.r')
    hold off
    

    figure
    clf
    geoshow(map, R, 'DisplayType','surface');
    contourcmap('jet',0:0.05:1, 'colorbar', 'on', 'location', 'vertical')
end
    

if isempty(outT)
    grap=false;
else
    grap=true;
end